version: '4.1'

services:
  web:
    image: nginx:latest  ## Uses an existing image from Docker Hub or registry.
    container_name: my-nginx-container  ## Assigns a custom container name.

    ports:
      - "8080:80"        ## Maps host port 8080 to container port 80 (TCP by default).
      - "8080:80/tcp"    ## Explicitly defines TCP protocol.
      - "8080-8081:80-81" ## Maps a range of ports from host to container.

    volumes:
      - ./hostPath:/containerPath:ro    ## Mounts host directory as read-only.
      - ./hostPath:/containerPath:rw    ## Mounts host directory as read-write.
      - volumeName:/containerPath:ro    ## Uses a named volume as read-only.
      - volumeName:/containerPath:rw    ## Uses a named volume as read-write.

    networks:
      - my_network   ## Connects the container to a specific network.

    environment:
      - NODE_ENV=production   ## Passes environment variables.
      - PORT=8080

    restart: always   ## Restart policy types:
                      ## - no: never restart
                      ## - always: always restart if stopped
                      ## - on-failure: restart only when container exits with error
                      ## - unless-stopped: restart unless manually stopped

    depends_on:
      - db     ## Ensures 'web' starts only after 'db' service starts.
      - app    ## Multiple dependencies can be listed.

    secrets:
      my_secret:   ## Mounts sensitive data securely from Docker secrets.
        file: ./secrets/my_secret.txt   ## Make sure this file exists

    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost"]  ## Command used to test container health.
      interval: 1m30s   ## Time between checks.
      timeout: 30s      ## Max time before a check is considered failed.
      retries: 5        ## Number of retries before marking as unhealthy.
      start_period: 30s ## Time before starting health checks.

    configs:
      - source: app_config   ## Config name defined under top-level configs section.
        target: /etc/config.json  ## Where config is mounted inside the container.

        app_config:
          file: ./configs/config.json     ## Make sure this file exists

    command: ["nginx", "-g", "daemon off;"]  ## Overrides default command for container.

    deploy:
      replicas: 3   ## Number of container instances (Swarm mode only).

    logging:
      driver: "json-file"   ## Logging driver to use.
      options:
        max-size: "10m"     ## Max size of log file before rotation.
        max-file: "3"       ## Max number of log files to keep.

      resources:
        limits:
          cpus: "0.5"   ## Max CPU allocation per container.
          memory: 512M  ## Max memory allocation per container.
        reservations:
          cpus: "0.25"  ## Minimum CPU reserved.
          memory: 256M  ## Minimum memory reserved.

      restart_policy:
        condition: on-failure  ## Restart only on container failure.
                               ## Types: none, on-failure, or any.
        delay: 5s              ## Wait time before restart.
        max_attempts: 3        ## Max number of restart tries.
        window: 120s           ## Time window to evaluate restart attempts.

      placement:
        constraints:
          - node.role == manager   ## Runs container only on Swarm manager nodes.
          - node.labels.region == us-east  ## Example of label-based constraint.


  app:
    build:   ## Build configuration for custom Docker image.
      context: ./appDirectory   ## Directory containing Dockerfile.
      dockerfile: dockerfile   ## Custom Dockerfile name or path.
      args:  ## Passes build arguments to the Dockerfile.
        - name=value
      target: ## Used for multi-stage builds. 
              ## You can specify which build stage in your Dockerfile to build up to. 
              ## Only the builder stage will be built.
      labels:   ## Adds metadata to the built image (not the running container).
          maintainer: "santosh@example.com"
          version: "1.0"
      network: host  ## Specifies which Docker network to connect to during the image build.
                     ##so your build process (like apt-get install or pip install) can access 
                     ##other services or the internet through that network.
      healthcheck:
        test: ["CMD-SHELL", "curl -f http://localhost/health || exit 1"]  ## Health check for the build process.
        interval: 1m
        timeout: 10s
        retries: 3
        
  db:
    image: postgres:latest               ## Pulls the latest PostgreSQL image from Docker Hub.
    container_name: postgres-db          ## Assigns a custom name to the container.
    
    environment:
      POSTGRES_USER: user                ## Database username.
      POSTGRES_PASSWORD: password        ## Database password.
      POSTGRES_DB: mydatabase            ## Automatically creates this database on startup.

    ports:
      - "5432:5432"                      ## Maps host port 5432 to container port 5432.

    volumes:
      - db_data:/var/lib/postgresql/data ## Persists Postgres data in a named volume.

    networks:
      - backend_network6                 ## Connects to the bridge network defined below.

    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U user"]  ## Verifies Postgres readiness.
      interval: 30s                      ## Runs health check every 30 seconds.
      timeout: 10s                       ## Fails if check takes longer than 10 seconds.
      retries: 5                         ## Marks container unhealthy after 5 failures.

    restart: unless-stopped              ## Restarts automatically unless manually stopped.


  redis:
    image: redis:latest                  ## Pulls the latest Redis image from Docker Hub.
    container_name: my-redis-container   ## Custom container name for Redis.

    ports:
      - "6379:6379"                      ## Maps Redis default port (6379) to host.

    networks:
      - backend_network6                 ## Uses the same network as Postgres to communicate.

    volumes:
      - redis_data:/data                 ## Persists Redis data in a named volume.

    healthcheck:
      test: ["CMD", "redis-cli", "ping"] ## Checks Redis availability with a PING command.
      interval: 30s
      timeout: 10s
      retries: 5

    restart: unless-stopped              ## Ensures Redis restarts if it stops unexpectedly.


networks:
  ## ===== FRONTEND NETWORK TYPES ===== ##
  frontend_network:
    driver: bridge   ## Bridge network — default; isolates containers on the same host.
  frontend_network2:
    driver: ipvlan   ## IPvlan network — advanced control over container IP addressing.
  frontend_network4:
    driver: overlay  ## Overlay network — used for multi-host communication (Swarm).
  frontend_network5:
    driver: host     ## Host network — shares host’s network stack for direct access.
  frontend_network6:
    driver: none     ## None — disables networking for container isolation.
  frontend_network7:
    driver: macvlan  ## Macvlan — assigns containers unique MAC & IP on host’s LAN.
  frontend_network8:
    driver: null     ## Null — synonym for none; no networking.

  ## ===== BACKEND NETWORK TYPES ===== ##
  backend_network:
    driver: overlay  ## Overlay — used in Swarm for service-to-service communication.
  backend_network2:
    driver: macvlan  ## Macvlan — gives containers direct access to physical network.
  backend_network3:
    driver: host     ## Host — runs containers with host’s IP (high performance, less isolation).
  backend_network4:
    driver: none     ## None — isolates container without networking.
  backend_network5:
    driver: null     ## Null — same as none, disables networking.
  backend_network6:
    driver: bridge   ## Bridge — default single-host network for inter-container communication.
  backend_network7:
    driver: ipvlan   ## IPvlan — allows more flexible container-to-host routing setups.


volumes:
  db_data:     ## Named volume for Postgres data persistence.
  redis_data:  ## Named volume for Redis data persistence.
